/* tslint:disable */
/* eslint-disable */
/**
 * Selling Partner API for Supply Sources
 * Manage configurations and capabilities of seller supply sources.
 *
 * The version of the OpenAPI document: 2020-07-01
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * A physical address.
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * The name of the person, business or institution at that address.
     * @type {string}
     * @memberof Address
     */
    name: string;
    /**
     * The first line of the address.
     * @type {string}
     * @memberof Address
     */
    addressLine1: string;
    /**
     * The additional address information, if required.
     * @type {string}
     * @memberof Address
     */
    addressLine2?: string;
    /**
     * The additional address information, if required.
     * @type {string}
     * @memberof Address
     */
    addressLine3?: string;
    /**
     * The city where the person, business or institution is located.
     * @type {string}
     * @memberof Address
     */
    city?: string;
    /**
     * The county where person, business or institution is located.
     * @type {string}
     * @memberof Address
     */
    county?: string;
    /**
     * The district where person, business or institution is located.
     * @type {string}
     * @memberof Address
     */
    district?: string;
    /**
     * The state or region where person, business or institution is located.
     * @type {string}
     * @memberof Address
     */
    stateOrRegion: string;
    /**
     * The postal code of that address. It conatins a series of letters or digits or both, sometimes including spaces or punctuation.
     * @type {string}
     * @memberof Address
     */
    postalCode?: string;
    /**
     * The two digit country code. In ISO 3166-1 alpha-2 format.
     * @type {string}
     * @memberof Address
     */
    countryCode: string;
    /**
     * The phone number of the person, business or institution located at that address.
     * @type {string}
     * @memberof Address
     */
    phone?: string;
}
/**
 * The address and contact details.
 * @export
 * @interface AddressWithContact
 */
export interface AddressWithContact {
    /**
     * 
     * @type {ContactDetails}
     * @memberof AddressWithContact
     */
    contactDetails?: ContactDetails;
    /**
     * 
     * @type {Address}
     * @memberof AddressWithContact
     */
    address?: Address;
}
/**
 * The contact details
 * @export
 * @interface ContactDetails
 */
export interface ContactDetails {
    /**
     * 
     * @type {ContactDetailsPrimary}
     * @memberof ContactDetails
     */
    primary?: ContactDetailsPrimary;
}
/**
 * 
 * @export
 * @interface ContactDetailsPrimary
 */
export interface ContactDetailsPrimary {
    /**
     * The email address to which email messages are delivered.
     * @type {string}
     * @memberof ContactDetailsPrimary
     */
    email?: string;
    /**
     * The phone number of the person, business or institution.
     * @type {string}
     * @memberof ContactDetailsPrimary
     */
    phone?: string;
}
/**
 * A request to create a supply source.
 * @export
 * @interface CreateSupplySourceRequest
 */
export interface CreateSupplySourceRequest {
    /**
     * The seller-provided unique supply source code.
     * @type {string}
     * @memberof CreateSupplySourceRequest
     */
    supplySourceCode: string;
    /**
     * The custom alias for this supply source
     * @type {string}
     * @memberof CreateSupplySourceRequest
     */
    alias: string;
    /**
     * 
     * @type {Address}
     * @memberof CreateSupplySourceRequest
     */
    address: Address;
}
/**
 * The result of creating a new supply source.
 * @export
 * @interface CreateSupplySourceResponse
 */
export interface CreateSupplySourceResponse {
    /**
     * An Amazon generated unique supply source ID.
     * @type {string}
     * @memberof CreateSupplySourceResponse
     */
    supplySourceId: string;
    /**
     * The seller-provided unique supply source code.
     * @type {string}
     * @memberof CreateSupplySourceResponse
     */
    supplySourceCode: string;
}
/**
 * The curbside pickup configuration of a supply source.
 * @export
 * @interface CurbsidePickupConfiguration
 */
export interface CurbsidePickupConfiguration {
    /**
     * When true, curbside pickup is supported by the supply source.
     * @type {boolean}
     * @memberof CurbsidePickupConfiguration
     */
    isSupported?: boolean;
    /**
     * 
     * @type {OperationalConfiguration}
     * @memberof CurbsidePickupConfiguration
     */
    operationalConfiguration?: OperationalConfiguration;
    /**
     * 
     * @type {ParkingWithAddressConfiguration}
     * @memberof CurbsidePickupConfiguration
     */
    parkingWithAddressConfiguration?: ParkingWithAddressConfiguration;
}
/**
 * The delivery channel of a supply source.
 * @export
 * @interface DeliveryChannel
 */
export interface DeliveryChannel {
    /**
     * 
     * @type {boolean}
     * @memberof DeliveryChannel
     */
    isSupported?: boolean;
    /**
     * 
     * @type {OperationalConfiguration}
     * @memberof DeliveryChannel
     */
    operationalConfiguration?: OperationalConfiguration;
}
/**
 * The duration of time.
 * @export
 * @interface Duration
 */
export interface Duration {
    /**
     * An unsigned integer that can be only positive or zero.
     * @type {number}
     * @memberof Duration
     */
    value?: number;
    /**
     * 
     * @type {TimeUnit}
     * @memberof Duration
     */
    timeUnit?: TimeUnit | 'Hours' | 'Minutes' | 'Days';
}
/**
 * A list of error responses returned when a request is unsuccessful.
 * @export
 * @interface ErrorList
 */
export interface ErrorList {
    /**
     * A list of error responses returned when a request is unsuccessful.
     * @type {Array<Error>}
     * @memberof ErrorList
     */
    errors: Array<Error>;
}
/**
 * The paginated list of supply sources.
 * @export
 * @interface GetSupplySourcesResponse
 */
export interface GetSupplySourcesResponse {
    /**
     * The list of `SupplySource`s.
     * @type {Array<object>}
     * @memberof GetSupplySourcesResponse
     */
    supplySources?: Array<object>;
    /**
     * If present, use this pagination token to retrieve the next page of supply sources.
     * @type {string}
     * @memberof GetSupplySourcesResponse
     */
    nextPageToken?: string;
}
/**
 * The in-store pickup configuration of a supply source.
 * @export
 * @interface InStorePickupConfiguration
 */
export interface InStorePickupConfiguration {
    /**
     * When true, in-store pickup is supported by the supply source (default: `isSupported` value in `PickupChannel`).
     * @type {boolean}
     * @memberof InStorePickupConfiguration
     */
    isSupported?: boolean;
    /**
     * 
     * @type {ParkingConfiguration}
     * @memberof InStorePickupConfiguration
     */
    parkingConfiguration?: ParkingConfiguration;
}
/**
 * An error response returned when the request is unsuccessful.
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * An error code that identifies the type of error that occured.
     * @type {string}
     * @memberof ModelError
     */
    code: string;
    /**
     * A message that describes the error condition in a human-readable form.
     * @type {string}
     * @memberof ModelError
     */
    message: string;
    /**
     * The additional details that can help the caller understand or fix the issue.
     * @type {string}
     * @memberof ModelError
     */
    details?: string;
}
/**
 * The operating hour schema
 * @export
 * @interface OperatingHour
 */
export interface OperatingHour {
    /**
     * The opening time, ISO 8601 formatted timestamp without date, HH:mm.
     * @type {string}
     * @memberof OperatingHour
     */
    startTime?: string;
    /**
     * The closing time, ISO 8601 formatted timestamp without date, HH:mm.
     * @type {string}
     * @memberof OperatingHour
     */
    endTime?: string;
}
/**
 * The operating hours per day
 * @export
 * @interface OperatingHoursByDay
 */
export interface OperatingHoursByDay {
    /**
     * A list of Operating Hours.
     * @type {Array<OperatingHour>}
     * @memberof OperatingHoursByDay
     */
    monday?: Array<OperatingHour>;
    /**
     * A list of Operating Hours.
     * @type {Array<OperatingHour>}
     * @memberof OperatingHoursByDay
     */
    tuesday?: Array<OperatingHour>;
    /**
     * A list of Operating Hours.
     * @type {Array<OperatingHour>}
     * @memberof OperatingHoursByDay
     */
    wednesday?: Array<OperatingHour>;
    /**
     * A list of Operating Hours.
     * @type {Array<OperatingHour>}
     * @memberof OperatingHoursByDay
     */
    thursday?: Array<OperatingHour>;
    /**
     * A list of Operating Hours.
     * @type {Array<OperatingHour>}
     * @memberof OperatingHoursByDay
     */
    friday?: Array<OperatingHour>;
    /**
     * A list of Operating Hours.
     * @type {Array<OperatingHour>}
     * @memberof OperatingHoursByDay
     */
    saturday?: Array<OperatingHour>;
    /**
     * A list of Operating Hours.
     * @type {Array<OperatingHour>}
     * @memberof OperatingHoursByDay
     */
    sunday?: Array<OperatingHour>;
}
/**
 * The operational configuration of `supplySources`.
 * @export
 * @interface OperationalConfiguration
 */
export interface OperationalConfiguration {
    /**
     * 
     * @type {ContactDetails}
     * @memberof OperationalConfiguration
     */
    contactDetails?: ContactDetails;
    /**
     * 
     * @type {ThroughputConfig}
     * @memberof OperationalConfiguration
     */
    throughputConfig?: ThroughputConfig;
    /**
     * 
     * @type {OperatingHoursByDay}
     * @memberof OperationalConfiguration
     */
    operatingHoursByDay?: OperatingHoursByDay;
    /**
     * 
     * @type {Duration}
     * @memberof OperationalConfiguration
     */
    handlingTime?: Duration;
}
/**
 * The outbound capability of a supply source.
 * @export
 * @interface OutboundCapability
 */
export interface OutboundCapability {
    /**
     * 
     * @type {boolean}
     * @memberof OutboundCapability
     */
    isSupported?: boolean;
    /**
     * 
     * @type {OperationalConfiguration}
     * @memberof OutboundCapability
     */
    operationalConfiguration?: OperationalConfiguration;
    /**
     * 
     * @type {ReturnLocation}
     * @memberof OutboundCapability
     */
    returnLocation?: ReturnLocation;
    /**
     * 
     * @type {DeliveryChannel}
     * @memberof OutboundCapability
     */
    deliveryChannel?: DeliveryChannel;
    /**
     * 
     * @type {PickupChannel}
     * @memberof OutboundCapability
     */
    pickupChannel?: PickupChannel;
}
/**
 * The parking configuration.
 * @export
 * @interface ParkingConfiguration
 */
export interface ParkingConfiguration {
    /**
     * 
     * @type {ParkingCostType}
     * @memberof ParkingConfiguration
     */
    parkingCostType?: ParkingCostType | 'Free' | 'Other';
    /**
     * 
     * @type {ParkingSpotIdentificationType}
     * @memberof ParkingConfiguration
     */
    parkingSpotIdentificationType?: ParkingSpotIdentificationType | 'Numbered' | 'Other';
    /**
     * An unsigned integer that can be only positive or zero.
     * @type {number}
     * @memberof ParkingConfiguration
     */
    numberOfParkingSpots?: number;
}
/**
 * The parking cost type.
 * @export
 * @enum {string}
 */
export enum ParkingCostType {
    Free = 'Free',
    Other = 'Other'
}

/**
 * The type of parking spot identification.
 * @export
 * @enum {string}
 */
export enum ParkingSpotIdentificationType {
    Numbered = 'Numbered',
    Other = 'Other'
}

/**
 * The parking configuration with the address.
 * @export
 * @interface ParkingWithAddressConfiguration
 */
export interface ParkingWithAddressConfiguration {
    /**
     * 
     * @type {ParkingCostType}
     * @memberof ParkingWithAddressConfiguration
     */
    parkingCostType?: ParkingCostType | 'Free' | 'Other';
    /**
     * 
     * @type {ParkingSpotIdentificationType}
     * @memberof ParkingWithAddressConfiguration
     */
    parkingSpotIdentificationType?: ParkingSpotIdentificationType | 'Numbered' | 'Other';
    /**
     * An unsigned integer that can be only positive or zero.
     * @type {number}
     * @memberof ParkingWithAddressConfiguration
     */
    numberOfParkingSpots?: number;
    /**
     * 
     * @type {Address}
     * @memberof ParkingWithAddressConfiguration
     */
    address?: Address;
}
/**
 * 
 * @export
 * @interface ParkingWithAddressConfigurationAllOf
 */
export interface ParkingWithAddressConfigurationAllOf {
    /**
     * 
     * @type {Address}
     * @memberof ParkingWithAddressConfigurationAllOf
     */
    address?: Address;
}
/**
 * The pick up channel of a supply source.
 * @export
 * @interface PickupChannel
 */
export interface PickupChannel {
    /**
     * 
     * @type {Duration}
     * @memberof PickupChannel
     */
    inventoryHoldPeriod?: Duration;
    /**
     * 
     * @type {boolean}
     * @memberof PickupChannel
     */
    isSupported?: boolean;
    /**
     * 
     * @type {OperationalConfiguration}
     * @memberof PickupChannel
     */
    operationalConfiguration?: OperationalConfiguration;
    /**
     * 
     * @type {InStorePickupConfiguration}
     * @memberof PickupChannel
     */
    inStorePickupConfiguration?: InStorePickupConfiguration;
    /**
     * 
     * @type {CurbsidePickupConfiguration}
     * @memberof PickupChannel
     */
    curbsidePickupConfiguration?: CurbsidePickupConfiguration;
}
/**
 * The address or reference to another `supplySourceId` to act as a return location.
 * @export
 * @interface ReturnLocation
 */
export interface ReturnLocation {
    /**
     * The Amazon provided `supplySourceId` where orders can be returned to.
     * @type {string}
     * @memberof ReturnLocation
     */
    supplySourceId?: string;
    /**
     * 
     * @type {AddressWithContact}
     * @memberof ReturnLocation
     */
    addressWithContact?: AddressWithContact;
}
/**
 * The services capability of a supply source.
 * @export
 * @interface ServicesCapability
 */
export interface ServicesCapability {
    /**
     * When true, `SupplySource` supports the Service capability.
     * @type {boolean}
     * @memberof ServicesCapability
     */
    isSupported?: boolean;
    /**
     * 
     * @type {OperationalConfiguration}
     * @memberof ServicesCapability
     */
    operationalConfiguration?: OperationalConfiguration;
}
/**
 * The supply source details, including configurations and capabilities.
 * @export
 * @interface SupplySource
 */
export interface SupplySource {
    /**
     * An Amazon generated unique supply source ID.
     * @type {string}
     * @memberof SupplySource
     */
    supplySourceId?: string;
    /**
     * The seller-provided unique supply source code.
     * @type {string}
     * @memberof SupplySource
     */
    supplySourceCode?: string;
    /**
     * The custom alias for this supply source
     * @type {string}
     * @memberof SupplySource
     */
    alias?: string;
    /**
     * 
     * @type {SupplySourceStatusReadOnly}
     * @memberof SupplySource
     */
    status?: SupplySourceStatusReadOnly | 'Active' | 'Inactive' | 'Archived';
    /**
     * 
     * @type {Address}
     * @memberof SupplySource
     */
    address?: Address;
    /**
     * 
     * @type {SupplySourceConfiguration}
     * @memberof SupplySource
     */
    configuration?: SupplySourceConfiguration;
    /**
     * 
     * @type {SupplySourceCapabilities}
     * @memberof SupplySource
     */
    capabilities?: SupplySourceCapabilities;
    /**
     * A date and time in the rfc3339 format.
     * @type {string}
     * @memberof SupplySource
     */
    createdAt?: string;
    /**
     * A date and time in the rfc3339 format.
     * @type {string}
     * @memberof SupplySource
     */
    updatedAt?: string;
}
/**
 * The capabilities of a supply source.
 * @export
 * @interface SupplySourceCapabilities
 */
export interface SupplySourceCapabilities {
    /**
     * 
     * @type {OutboundCapability}
     * @memberof SupplySourceCapabilities
     */
    outbound?: OutboundCapability;
    /**
     * 
     * @type {ServicesCapability}
     * @memberof SupplySourceCapabilities
     */
    services?: ServicesCapability;
}
/**
 * Includes configuration and timezone of a supply source.
 * @export
 * @interface SupplySourceConfiguration
 */
export interface SupplySourceConfiguration {
    /**
     * 
     * @type {OperationalConfiguration}
     * @memberof SupplySourceConfiguration
     */
    operationalConfiguration?: OperationalConfiguration;
    /**
     * Please see RFC 6557, should be a canonical time zone ID as listed here: https://www.joda.org/joda-time/timezones.html.
     * @type {string}
     * @memberof SupplySourceConfiguration
     */
    timezone?: string;
}
/**
 * The `SupplySource` status
 * @export
 * @enum {string}
 */
export enum SupplySourceStatus {
    Active = 'Active',
    Inactive = 'Inactive'
}

/**
 * The `SupplySource` status.
 * @export
 * @enum {string}
 */
export enum SupplySourceStatusReadOnly {
    Active = 'Active',
    Inactive = 'Inactive',
    Archived = 'Archived'
}

/**
 * The throughput capacity
 * @export
 * @interface ThroughputCap
 */
export interface ThroughputCap {
    /**
     * An unsigned integer that can be only positive or zero.
     * @type {number}
     * @memberof ThroughputCap
     */
    value?: number;
    /**
     * 
     * @type {TimeUnit}
     * @memberof ThroughputCap
     */
    timeUnit?: TimeUnit | 'Hours' | 'Minutes' | 'Days';
}
/**
 * The throughput configuration.
 * @export
 * @interface ThroughputConfig
 */
export interface ThroughputConfig {
    /**
     * 
     * @type {ThroughputCap}
     * @memberof ThroughputConfig
     */
    throughputCap?: ThroughputCap;
    /**
     * 
     * @type {ThroughputUnit}
     * @memberof ThroughputConfig
     */
    throughputUnit: ThroughputUnit | 'Order';
}
/**
 * The throughput unit
 * @export
 * @enum {string}
 */
export enum ThroughputUnit {
    Order = 'Order'
}

/**
 * The time unit
 * @export
 * @enum {string}
 */
export enum TimeUnit {
    Hours = 'Hours',
    Minutes = 'Minutes',
    Days = 'Days'
}

/**
 * A request to update the configuration and capabilities of a supply source.
 * @export
 * @interface UpdateSupplySourceRequest
 */
export interface UpdateSupplySourceRequest {
    /**
     * The custom alias for this supply source
     * @type {string}
     * @memberof UpdateSupplySourceRequest
     */
    alias?: string;
    /**
     * 
     * @type {SupplySourceConfiguration}
     * @memberof UpdateSupplySourceRequest
     */
    configuration?: SupplySourceConfiguration;
    /**
     * 
     * @type {SupplySourceCapabilities}
     * @memberof UpdateSupplySourceRequest
     */
    capabilities?: SupplySourceCapabilities;
}
/**
 * A request to update the status of a supply source.
 * @export
 * @interface UpdateSupplySourceStatusRequest
 */
export interface UpdateSupplySourceStatusRequest {
    /**
     * 
     * @type {SupplySourceStatus}
     * @memberof UpdateSupplySourceStatusRequest
     */
    status?: SupplySourceStatus | 'Active' | 'Inactive';
}

/**
 * SupplySourcesApi - axios parameter creator
 * @export
 */
export const SupplySourcesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Archive a supply source, making it inactive. Cannot be undone.
         * @param {string} supplySourceId The unique identifier of a supply source.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveSupplySource: async (supplySourceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplySourceId' is not null or undefined
            assertParamExists('archiveSupplySource', 'supplySourceId', supplySourceId)
            const localVarPath = `/supplySources/2020-07-01/supplySources/{supplySourceId}`
                .replace(`{${"supplySourceId"}}`, encodeURIComponent(String(supplySourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new supply source.
         * @param {CreateSupplySourceRequest} payload A request to create a supply source.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSupplySource: async (payload: CreateSupplySourceRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('createSupplySource', 'payload', payload)
            const localVarPath = `/supplySources/2020-07-01/supplySources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a supply source.
         * @param {string} supplySourceId The unique identifier of a supply source.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSupplySource: async (supplySourceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplySourceId' is not null or undefined
            assertParamExists('getSupplySource', 'supplySourceId', supplySourceId)
            const localVarPath = `/supplySources/2020-07-01/supplySources/{supplySourceId}`
                .replace(`{${"supplySourceId"}}`, encodeURIComponent(String(supplySourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The path to retrieve paginated supply sources.
         * @param {string} [nextPageToken] The pagination token to retrieve a specific page of results.
         * @param {number} [pageSize] The number of supply sources to return per paginated request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSupplySources: async (nextPageToken?: string, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/supplySources/2020-07-01/supplySources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (nextPageToken !== undefined) {
                localVarQueryParameter['nextPageToken'] = nextPageToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the configuration and capabilities of a supply source.
         * @param {string} supplySourceId The unique identitier of a supply source.
         * @param {UpdateSupplySourceRequest} [payload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSupplySource: async (supplySourceId: string, payload?: UpdateSupplySourceRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplySourceId' is not null or undefined
            assertParamExists('updateSupplySource', 'supplySourceId', supplySourceId)
            const localVarPath = `/supplySources/2020-07-01/supplySources/{supplySourceId}`
                .replace(`{${"supplySourceId"}}`, encodeURIComponent(String(supplySourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the status of a supply source.
         * @param {string} supplySourceId The unique identifier of a supply source.
         * @param {UpdateSupplySourceStatusRequest} [payload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSupplySourceStatus: async (supplySourceId: string, payload?: UpdateSupplySourceStatusRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplySourceId' is not null or undefined
            assertParamExists('updateSupplySourceStatus', 'supplySourceId', supplySourceId)
            const localVarPath = `/supplySources/2020-07-01/supplySources/{supplySourceId}/status`
                .replace(`{${"supplySourceId"}}`, encodeURIComponent(String(supplySourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SupplySourcesApi - functional programming interface
 * @export
 */
export const SupplySourcesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SupplySourcesApiAxiosParamCreator(configuration)
    return {
        /**
         * Archive a supply source, making it inactive. Cannot be undone.
         * @param {string} supplySourceId The unique identifier of a supply source.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archiveSupplySource(supplySourceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ErrorList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.archiveSupplySource(supplySourceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new supply source.
         * @param {CreateSupplySourceRequest} payload A request to create a supply source.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSupplySource(payload: CreateSupplySourceRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateSupplySourceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSupplySource(payload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a supply source.
         * @param {string} supplySourceId The unique identifier of a supply source.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSupplySource(supplySourceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplySource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSupplySource(supplySourceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The path to retrieve paginated supply sources.
         * @param {string} [nextPageToken] The pagination token to retrieve a specific page of results.
         * @param {number} [pageSize] The number of supply sources to return per paginated request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSupplySources(nextPageToken?: string, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSupplySourcesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSupplySources(nextPageToken, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the configuration and capabilities of a supply source.
         * @param {string} supplySourceId The unique identitier of a supply source.
         * @param {UpdateSupplySourceRequest} [payload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSupplySource(supplySourceId: string, payload?: UpdateSupplySourceRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ErrorList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSupplySource(supplySourceId, payload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the status of a supply source.
         * @param {string} supplySourceId The unique identifier of a supply source.
         * @param {UpdateSupplySourceStatusRequest} [payload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSupplySourceStatus(supplySourceId: string, payload?: UpdateSupplySourceStatusRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ErrorList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSupplySourceStatus(supplySourceId, payload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SupplySourcesApi - factory interface
 * @export
 */
export const SupplySourcesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SupplySourcesApiFp(configuration)
    return {
        /**
         * Archive a supply source, making it inactive. Cannot be undone.
         * @param {string} supplySourceId The unique identifier of a supply source.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveSupplySource(supplySourceId: string, options?: any): AxiosPromise<ErrorList> {
            return localVarFp.archiveSupplySource(supplySourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new supply source.
         * @param {CreateSupplySourceRequest} payload A request to create a supply source.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSupplySource(payload: CreateSupplySourceRequest, options?: any): AxiosPromise<CreateSupplySourceResponse> {
            return localVarFp.createSupplySource(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a supply source.
         * @param {string} supplySourceId The unique identifier of a supply source.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSupplySource(supplySourceId: string, options?: any): AxiosPromise<SupplySource> {
            return localVarFp.getSupplySource(supplySourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * The path to retrieve paginated supply sources.
         * @param {string} [nextPageToken] The pagination token to retrieve a specific page of results.
         * @param {number} [pageSize] The number of supply sources to return per paginated request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSupplySources(nextPageToken?: string, pageSize?: number, options?: any): AxiosPromise<GetSupplySourcesResponse> {
            return localVarFp.getSupplySources(nextPageToken, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the configuration and capabilities of a supply source.
         * @param {string} supplySourceId The unique identitier of a supply source.
         * @param {UpdateSupplySourceRequest} [payload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSupplySource(supplySourceId: string, payload?: UpdateSupplySourceRequest, options?: any): AxiosPromise<ErrorList> {
            return localVarFp.updateSupplySource(supplySourceId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the status of a supply source.
         * @param {string} supplySourceId The unique identifier of a supply source.
         * @param {UpdateSupplySourceStatusRequest} [payload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSupplySourceStatus(supplySourceId: string, payload?: UpdateSupplySourceStatusRequest, options?: any): AxiosPromise<ErrorList> {
            return localVarFp.updateSupplySourceStatus(supplySourceId, payload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for archiveSupplySource operation in SupplySourcesApi.
 * @export
 * @interface SupplySourcesApiArchiveSupplySourceRequest
 */
export interface SupplySourcesApiArchiveSupplySourceRequest {
    /**
     * The unique identifier of a supply source.
     * @type {string}
     * @memberof SupplySourcesApiArchiveSupplySource
     */
    readonly supplySourceId: string
}

/**
 * Request parameters for createSupplySource operation in SupplySourcesApi.
 * @export
 * @interface SupplySourcesApiCreateSupplySourceRequest
 */
export interface SupplySourcesApiCreateSupplySourceRequest {
    /**
     * A request to create a supply source.
     * @type {CreateSupplySourceRequest}
     * @memberof SupplySourcesApiCreateSupplySource
     */
    readonly payload: CreateSupplySourceRequest
}

/**
 * Request parameters for getSupplySource operation in SupplySourcesApi.
 * @export
 * @interface SupplySourcesApiGetSupplySourceRequest
 */
export interface SupplySourcesApiGetSupplySourceRequest {
    /**
     * The unique identifier of a supply source.
     * @type {string}
     * @memberof SupplySourcesApiGetSupplySource
     */
    readonly supplySourceId: string
}

/**
 * Request parameters for getSupplySources operation in SupplySourcesApi.
 * @export
 * @interface SupplySourcesApiGetSupplySourcesRequest
 */
export interface SupplySourcesApiGetSupplySourcesRequest {
    /**
     * The pagination token to retrieve a specific page of results.
     * @type {string}
     * @memberof SupplySourcesApiGetSupplySources
     */
    readonly nextPageToken?: string

    /**
     * The number of supply sources to return per paginated request.
     * @type {number}
     * @memberof SupplySourcesApiGetSupplySources
     */
    readonly pageSize?: number
}

/**
 * Request parameters for updateSupplySource operation in SupplySourcesApi.
 * @export
 * @interface SupplySourcesApiUpdateSupplySourceRequest
 */
export interface SupplySourcesApiUpdateSupplySourceRequest {
    /**
     * The unique identitier of a supply source.
     * @type {string}
     * @memberof SupplySourcesApiUpdateSupplySource
     */
    readonly supplySourceId: string

    /**
     * 
     * @type {UpdateSupplySourceRequest}
     * @memberof SupplySourcesApiUpdateSupplySource
     */
    readonly payload?: UpdateSupplySourceRequest
}

/**
 * Request parameters for updateSupplySourceStatus operation in SupplySourcesApi.
 * @export
 * @interface SupplySourcesApiUpdateSupplySourceStatusRequest
 */
export interface SupplySourcesApiUpdateSupplySourceStatusRequest {
    /**
     * The unique identifier of a supply source.
     * @type {string}
     * @memberof SupplySourcesApiUpdateSupplySourceStatus
     */
    readonly supplySourceId: string

    /**
     * 
     * @type {UpdateSupplySourceStatusRequest}
     * @memberof SupplySourcesApiUpdateSupplySourceStatus
     */
    readonly payload?: UpdateSupplySourceStatusRequest
}

/**
 * SupplySourcesApi - object-oriented interface
 * @export
 * @class SupplySourcesApi
 * @extends {BaseAPI}
 */
export class SupplySourcesApi extends BaseAPI {
    /**
     * Archive a supply source, making it inactive. Cannot be undone.
     * @param {SupplySourcesApiArchiveSupplySourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupplySourcesApi
     */
    public archiveSupplySource(requestParameters: SupplySourcesApiArchiveSupplySourceRequest, options?: any) {
        return SupplySourcesApiFp(this.configuration).archiveSupplySource(requestParameters.supplySourceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new supply source.
     * @param {SupplySourcesApiCreateSupplySourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupplySourcesApi
     */
    public createSupplySource(requestParameters: SupplySourcesApiCreateSupplySourceRequest, options?: any) {
        return SupplySourcesApiFp(this.configuration).createSupplySource(requestParameters.payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a supply source.
     * @param {SupplySourcesApiGetSupplySourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupplySourcesApi
     */
    public getSupplySource(requestParameters: SupplySourcesApiGetSupplySourceRequest, options?: any) {
        return SupplySourcesApiFp(this.configuration).getSupplySource(requestParameters.supplySourceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The path to retrieve paginated supply sources.
     * @param {SupplySourcesApiGetSupplySourcesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupplySourcesApi
     */
    public getSupplySources(requestParameters: SupplySourcesApiGetSupplySourcesRequest = {}, options?: any) {
        return SupplySourcesApiFp(this.configuration).getSupplySources(requestParameters.nextPageToken, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the configuration and capabilities of a supply source.
     * @param {SupplySourcesApiUpdateSupplySourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupplySourcesApi
     */
    public updateSupplySource(requestParameters: SupplySourcesApiUpdateSupplySourceRequest, options?: any) {
        return SupplySourcesApiFp(this.configuration).updateSupplySource(requestParameters.supplySourceId, requestParameters.payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the status of a supply source.
     * @param {SupplySourcesApiUpdateSupplySourceStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupplySourcesApi
     */
    public updateSupplySourceStatus(requestParameters: SupplySourcesApiUpdateSupplySourceStatusRequest, options?: any) {
        return SupplySourcesApiFp(this.configuration).updateSupplySourceStatus(requestParameters.supplySourceId, requestParameters.payload, options).then((request) => request(this.axios, this.basePath));
    }
}


